#!/usr/bin/env bash

set -Eeuo pipefail

rootfs="$1"
img="$2"

if [[ -e "$img" ]]; then
    echo "$img already exists"
    exit 1
fi

rootfs_work=$(mktemp -d)
mnt=$(mktemp -d)

cp -a "$rootfs/." "$rootfs_work"

# setup systemd boot (setting SYSTEMD_ESP_PATH env needed to bypass bootctl checking if mounted from esp partition)
touch "$rootfs_work/boot/efi/loader/loader.conf"
chroot "$rootfs_work" /usr/bin/env -i SYSTEMD_ESP_PATH="/boot/efi" bootctl --no-variables install

fstab=$(mktemp)
second_pass=$(mktemp)

# --- first pass: process fstab and create file systems ---

# strip comments and blank lines
sed 's/#.*//;/^[[:blank:]]*$/d' |
while IFS= read -r line; do
	# get fstab entry target path depth
	depth=$(echo "$line" | awk '{ print $2 }' | sed 's#^/\+##;s#/\+$##' | awk -F '/' '{ print NF }')
	echo $depth "$line"
done |
sort -k 1 -n -r | # sort by path depth (deepest first)
while read depth source target fs options args; do
	# set dump and pass options for output fstab to defaults
	dump=0
	pass=$(([[ "$(cut -c 1 <<< "$target")" != "/" ]] && echo 0) || ([[ "$target" = "/" ]] && echo 1) || echo 2)
	echo "$source" "$target" "$fs" "$options" "$dump" "$pass" >> "$fstab"

	# parse extra fstab arguments to determine partition attributes
	type=linux
	size=
	resize=1
	syslinux=0
	while IFS="=" read key value; do
		case "$key" in
			"type")
				type="$value"
				;;
			"size")
				size="$value"
				resize=0
				;;
			"syslinux")
				syslinux=1
				;;
		esac
	done < <(echo "$args" | tr "," "\n")

	# check if fstab entry specifies source by UUID or LABEL
	uuid=$(grep -oP '(?<=^UUID=)[a-fA-F0-9\-]*$' <<< $source || true)
	label=$(grep -oP '(?<=^LABEL=)[a-zA-Z0-9\_\-]*$' <<< $source || true)

	# compute sufficiently padded size for partition (aligned to nearest MB (2048 sectors))
	size=${size:-$(du -sb "$rootfs_work$target" | awk '{ size = $1 * 1.25; padded_size = size + (MB - (size % MB) % MB); print (padded_size / MB) "MiB" }' 'MB=1048576')}

	file=$(mktemp)
	truncate -s "$size" "$file"

	case "$fs" in
		"ext4")
			mkfs.ext4 ${uuid:+"-U"} ${uuid:+"$uuid"} ${label:+"-L"} ${label:+"$label"} -I 256 "$file"
			;;
		"vfat")
			mkfs.vfat ${uuid:+"-i"} ${uuid:+"$uuid"} ${label:+"-n"} ${label:+"$label"} "$file"
			;;
		"swap")
			mkswap ${uuid:+"-U"} ${uuid:+"$uuid"} ${label:+"-L"} ${label:+"$label"} "$file"
			;;
	esac

	# for mount points (i.e. not swap, etc) copy from rootfs
	if [[ "$(cut -c 1 <<< "$target")" = "/" ]]; then
		mount -t "$fs" -o loop "$file" "$mnt"
		cp -a "$rootfs_work$target/." "$mnt"
		if [[ "$depth" = 0 ]]; then
			# we iterate depth sorted, so all other partitions should already have been processed and written to fstab
			cp "$fstab" "$mnt/etc/fstab"
		fi
		umount "$mnt"
		rm -rf "$rootfs_work$target"
		mkdir "$rootfs_work$target"
	fi

	# for ext4 set quota options and resize to minimum needed for contents (when run on a file resize2fs automatically truncates)
	if [[ "$fs" = "ext4" ]]; then
		tune2fs -Q usrquota,grpquota,prjquota "$file"
		if [[ "$resize" = 1 ]]; then
			e2fsck -y -f "$file"
			resize2fs -M "$file"
		fi
	fi

	# install syslinux if extra argument given in fstab
	if [[ "$syslinux" = 1 ]]; then
		PATH="$PATH:$rootfs/usr/bin" syslinux -d syslinux -i "$file"
	fi

	# recalc size, since it might have change (e.g. from resize2fs)
	size=$(du -b "$file" | awk '{ padded_size = $1 + (MB - ($1 % MB) % MB); print (padded_size / MB) }' 'MB=1048576')

	# known uuids (rather than auto generated by fdisk) needed to query offsets later on
	part_uuid=$(cat /proc/sys/kernel/random/uuid)

	echo -e "$part_uuid\t$type\t$size\t$syslinux\t$file\t$label" >> "$second_pass"
done

# --- first pass: assemble image ---

img_size=0
syslinux_mbr=0

# sum up partition sizes and check if any uses syslinux (=> will need to write syslinux to MBR)
while IFS=$'\t' read part_uuid type size syslinux file label; do
	img_size=$((img_size + size))
	if [[ "$syslinux" = 1 ]]; then
		syslinux_mbr=1
	fi
done < "$second_pass"

# add 2MiB as overhead for GPT
img_size=$((img_size + 2))

truncate -s "${img_size}MiB" "$img"

# setup partition table
{
	echo "label: gpt"
	while IFS=$'\t' read part_uuid type size syslinux file label; do
		echo "uuid=$part_uuid;type=$type;size=${size}MiB${label:+";name="}${label:+"$label"}$([[ "$syslinux" = 1 ]] && echo ";attrs=LegacyBIOSBootable" || true)"
	done < "$second_pass"
} | sfdisk "$img"

# when using syslinux on any partition write to MBR
if [[ "$syslinux_mbr" = 1 ]]; then
	dd if="$rootfs/usr/lib/SYSLINUX/gptmbr.bin" of="$img" bs=440 count=1 conv=notrunc
fi

gpt_dump=$(sfdisk -d "$img")

# sector_size should be 512, but query just to be safe
sector_size=$(grep -oP '(?<=sector-size: )[0-9]+' <<< "$gpt_dump")

while IFS=$'\t' read part_uuid type size syslinux file label; do
	# write partition to corresponding offset in image
	gpt_entry=$(grep -iF "uuid=$part_uuid" <<< "$gpt_dump")
	start_sector=$(grep -oP '(?<=start=) *[0-9]+' <<< "$gpt_entry" | tr -d '[:blank:]')
	num_sectors=$(grep -oP '(?<=size=) *[0-9]+' <<< "$gpt_entry" | tr -d '[:blank:]')
	dd if="$file" of="$img" bs="$sector_size" seek="$start_sector" count="$num_sectors" conv=notrunc
	rm "$file"
done < "$second_pass"

# cleanup
rm -rf "$rootfs_work" "$mnt" "$fstab" "$second_pass"
